""" Fields module for the Classical Quantum Biophysics (CQBP) framework.
This module provides implementations of various molecular field representations, including electron density fields, electrostatic potential fields, and specialized field transformations. """
import numpy as np 
from typing import Dict, List, Tuple, Union, Optional, Callable 
from scipy.spatial.distance import cdist 
from .core import Field, Operator, CompositeField
class GaussianField(Field): """ A field represented as a sum of Gaussian functions.
This is commonly used to represent electron density, electrostatic potential,
and other molecular properties in a smooth, continuous manner.
"""

def __init__(self, centers: np.ndarray, amplitudes: np.ndarray, 
             widths: np.ndarray, name: str = "GaussianField"):
    """
    Initialize a GaussianField.
    
    Parameters
    ----------
    centers : np.ndarray
        Array of shape (n, 3) containing the centers of the Gaussian functions
    amplitudes : np.ndarray
        Array of shape (n,) containing the amplitudes of the Gaussian functions
    widths : np.ndarray
        Array of shape (n,) containing the widths of the Gaussian functions
    name : str, optional
        Name of the field
    """
    super().__init__(name)
    self.centers = centers
    self.amplitudes = amplitudes
    self.widths = widths
    
def evaluate(self, points: np.ndarray) -> np.ndarray:
    """
    Evaluate the Gaussian field at specified points.
    
    Parameters
    ----------
    points : np.ndarray
        Array of shape (m, 3) containing the coordinates
        
    Returns
    -------
    np.ndarray
        Field values at the specified points
    """
    result = np.zeros(len(points))
    for center, amplitude, width in zip(self.centers, self.amplitudes, self.widths):
        # Calculate squared distances
        diff = points - center
        dist_sq = np.sum(diff**2, axis=1)
        # Add contribution from this Gaussian
        result += amplitude * np.exp(-dist_sq / (2 * width**2))
    return result
class MolecularField(Field): """ A field representing a molecular property based on atomic positions and parameters.
This class serves as a base for specific molecular fields like electrostatic potential,
steric fields, hydrophobic fields, etc.
"""

def __init__(self, atom_positions: np.ndarray, atom_parameters: np.ndarray, 
             interaction_function: Callable, name: str = "MolecularField"):
    """
    Initialize a MolecularField.
    
    Parameters
    ----------
    atom_positions : np.ndarray
        Array of shape (n, 3) containing atomic positions
    atom_parameters : np.ndarray
        Array of shape (n,) containing parameters for each atom (e.g., charges, radii)
    interaction_function : Callable
        Function that computes the interaction between a point and an atom
    name : str, optional
        Name of the field
    """
    super().__init__(name)
    self.atom_positions = atom_positions
    self.atom_parameters = atom_parameters
    self.interaction_function = interaction_function
    
def evaluate(self, points: np.ndarray) -> np.ndarray:
    """
    Evaluate the molecular field at specified points.
    
    Parameters
    ----------
    points : np.ndarray
        Array of shape (m, 3) containing the coordinates
        
    Returns
    -------
    np.ndarray
        Field values at the specified points
    """
    result = np.zeros(len(points))
    for pos, param in zip(self.atom_positions, self.atom_parameters):
        # Calculate contribution from this atom to all points
        contribution = self.interaction_function(points, pos, param)
        result += contribution
    return result
class ElectrostaticField(MolecularField): """ Electrostatic potential field generated by atomic partial charges. """
def __init__(self, atom_positions: np.ndarray, atom_charges: np.ndarray, 
             dielectric_constant: float = 1.0, name: str = "ElectrostaticField"):
    """
    Initialize an ElectrostaticField.
    
    Parameters
    ----------
    atom_positions : np.ndarray
        Array of shape (n, 3) containing atomic positions
    atom_charges : np.ndarray
        Array of shape (n,) containing atomic partial charges
    dielectric_constant : float, optional
        Dielectric constant of the medium
    name : str, optional
        Name of the field
    """
    def coulomb_interaction(points, atom_pos, charge):
        """Compute Coulomb interaction between points and an atom."""
        diff = points - atom_pos
        dist = np.sqrt(np.sum(diff**2, axis=1))
        # Avoid division by zero
        dist = np.maximum(dist, 1e-10)
        return charge / (dielectric_constant * dist)
        
    super().__init__(atom_positions, atom_charges, coulomb_interaction, name)
    self.dielectric_constant = dielectric_constant
class StericField(MolecularField): """ Steric field representing the spatial occupancy of a molecule. """
def __init__(self, atom_positions: np.ndarray, atom_radii: np.ndarray, 
             softness: float = 1.0, name: str = "StericField"):
    """
    Initialize a StericField.
    
    Parameters
    ----------
    atom_positions : np.ndarray
        Array of shape (n, 3) containing atomic positions
    atom_radii : np.ndarray
        Array of shape (n,) containing atomic van der Waals radii
    softness : float, optional
        Parameter controlling the softness of the steric boundary
    name : str, optional
        Name of the field
    """
    def steric_interaction(points, atom_pos, radius):
        """Compute steric interaction between points and an atom."""
        diff = points - atom_pos
        dist = np.sqrt(np.sum(diff**2, axis=1))
        # Soft-core steric potential
        return np.exp(-(dist - radius)**2 / softness)
        
    super().__init__(atom_positions, atom_radii, steric_interaction, name)
    self.softness = softness
class FieldTransformation(Operator): """ Base class for field transformations. """
def __init__(self, name: str = "FieldTransformation"):
    """
    Initialize a FieldTransformation.
    
    Parameters
    ----------
    name : str, optional
        Name of the transformation
    """
    super().__init__(name)

@abstractmethod
def apply(self, field: Field) -> Field:
    """
    Apply the transformation to a field.
    
    Parameters
    ----------
    field : Field
        The field to transform
        
    Returns
    -------
    Field
        The transformed field
    """
    pass
class GradientOperator(FieldTransformation): """ Operator that computes the gradient of a field. """
def __init__(self, step_size: float = 0.01, name: str = "Gradient"):
    """
    Initialize a GradientOperator.
    
    Parameters
    ----------
    step_size : float, optional
        Step size for finite difference approximation
    name : str, optional
        Name of the operator
    """
    super().__init__(name)
    self.step_size = step_size

def apply(self, field: Field) -> List[Field]:
    """
    Compute the gradient of a field using finite differences.
    
    Parameters
    ----------
    field : Field
        The field to differentiate
        
    Returns
    -------
    List[Field]
        The three components of the gradient field
    """
    h = self.step_size
    
    class GradientComponentField(Field):
        def __init__(self, original_field, component, step):
            super().__init__(f"\u2202{original_field.name}/\u2202{['x', 'y', 'z'][component]}")
            self.original_field = original_field
            self.component = component
            self.step = step
            
        def evaluate(self, points):
            # Create shifted points for finite difference
            points_plus = points.copy()
            points_minus = points.copy()
            points_plus[:, self.component] += self.step
            points_minus[:, self.component] -= self.step
            
            # Central difference approximation
            return (self.original_field.evaluate(points_plus) - 
                    self.original_field.evaluate(points_minus)) / (2 * self.step)
    
    # Return the three components of the gradient
    return [
        GradientComponentField(field, 0, h),
        GradientComponentField(field, 1, h),
        GradientComponentField(field, 2, h)
    ]
class LaplacianOperator(FieldTransformation): """ Operator that computes the Laplacian of a field. """
def __init__(self, step_size: float = 0.01, name: str = "Laplacian"):
    """
    Initialize a LaplacianOperator.
    
    Parameters
    ----------
    step_size : float, optional
        Step size for finite difference approximation
    name : str, optional
        Name of the operator
    """
    super().__init__(name)
    self.step_size = step_size

def apply(self, field: Field) -> Field:
    """
    Compute the Laplacian of a field using finite differences.
    
    Parameters
    ----------
    field : Field
        The field to differentiate
        
    Returns
    -------
    Field
        The Laplacian field
    """
    h = self.step_size
    
    class LaplacianField(Field):
        def __init__(self, original_field, step):
            super().__init__(f"\u2207\u00b2{original_field.name}")
            self.original_field = original_field
            self.step = step
            
        def evaluate(self, points):
            # Central point evaluation
            f_center = self.original_field.evaluate(points)
            laplacian = np.zeros_like(f_center)
            
            # Second derivatives in each direction
            for i in range(3):
                # Create shifted points for finite difference
                points_plus = points.copy()
                points_minus = points.copy()
                points_plus[:, i] += self.step
                points_minus[:, i] -= self.step
                
                # Second derivative approximation
                f_plus = self.original_field.evaluate(points_plus)
                f_minus = self.original_field.evaluate(points_minus)
                laplacian += (f_plus + f_minus - 2 * f_center) / (self.step**2)
            
            return laplacian
    
    return LaplacianField(field, h)
class FieldSimilarityMetric: """ Base class for metrics that quantify similarity between fields. """
def __init__(self, name: str = "FieldSimilarity"):
    """
    Initialize a FieldSimilarityMetric.
    
    Parameters
    ----------
    name : str, optional
        Name of the metric
    """
    self.name = name

@abstractmethod
def compute(self, field1: Field, field2: Field, points: np.ndarray) -> float:
    """
    Compute the similarity between two fields.
    
    Parameters
    ----------
    field1 : Field
        First field
    field2 : Field
        Second field
    points : np.ndarray
        Points at which to evaluate the fields
        
    Returns
    -------
    float
        Similarity score
    """
    pass
class CosineSimilarity(FieldSimilarityMetric): """ Cosine similarity between two fields. """
def __init__(self, name: str = "CosineSimilarity"):
    """
    Initialize a CosineSimilarity metric.
    
    Parameters
    ----------
    name : str, optional
        Name of the metric
    """
    super().__init__(name)

def compute(self, field1: Field, field2: Field, points: np.ndarray) -> float:
    """
    Compute the cosine similarity between two fields.
    
    Parameters
    ----------
    field1 : Field
        First field
    field2 : Field
        Second field
    points : np.ndarray
        Points at which to evaluate the fields
        
    Returns
    -------
    float
        Cosine similarity score in range [-1, 1]
    """
    # Evaluate fields at the specified points
    values1 = field1.evaluate(points)
    values2 = field2.evaluate(points)
    
    # Compute cosine similarity
    dot_product = np.sum(values1 * values2)
    norm1 = np.sqrt(np.sum(values1**2))
    norm2 = np.sqrt(np.sum(values2**2))
    
    # Avoid division by zero
    if norm1 < 1e-10 or norm2 < 1e-10:
        return 0.0
        
    return dot_product / (norm1 * norm2)
class TanimotoSimilarity(FieldSimilarityMetric): """ Tanimoto similarity between two fields. """
def __init__(self, name: str = "TanimotoSimilarity"):
    """
    Initialize a TanimotoSimilarity metric.
    
    Parameters
    ----------
    name : str, optional
        Name of the metric
    """
    super().__init__(name)

def compute(self, field1: Field, field2: Field, points: np.ndarray) -> float:
    """
    Compute the Tanimoto similarity between two fields.
    
    Parameters
    ----------
    field1 : Field
        First field
    field2 : Field
        Second field
    points : np.ndarray
        Points at which to evaluate the fields
        
    Returns
    -------
    float
        Tanimoto similarity score in range [0, 1]
    """
    # Evaluate fields at the specified points
    values1 = field1.evaluate(points)
    values2 = field2.evaluate(points)
    
    # Compute Tanimoto similarity
    dot_product = np.sum(values1 * values2)
    sum_squares1 = np.sum(values1**2)
    sum_squares2 = np.sum(values2**2)
    
    # Avoid division by zero
    denominator = sum_squares1 + sum_squares2 - dot_product
    if denominator < 1e-10:
        return 0.0 if dot_product < 1e-10 else 1.0
        
    return dot_product / denominator
class FieldInterpolation: """ Methods for interpolating between fields. """
@staticmethod
def linear_interpolation(field1: Field, field2: Field, alpha: float) -> Field:
    """
    Linear interpolation between two fields.
    
    Parameters
    ----------
    field1 : Field
        First field
    field2 : Field
        Second field
    alpha : float
        Interpolation parameter in range [0, 1]
        
    Returns
    -------
    Field
        Interpolated field
    """
    return CompositeField([field1, field2], [1 - alpha, alpha])

@staticmethod
def exponential_interpolation(field1: Field, field2: Field, alpha: float) -> Field:
    """
    Exponential interpolation between two fields.
    
    Parameters
    ----------
    field1 : Field
        First field
    field2 : Field
        Second field
    alpha : float
        Interpolation parameter in range [0, 1]
        
    Returns
    -------
    Field
        Interpolated field
    """
    class ExpInterpolatedField(Field):
        def __init__(self, f1, f2, a):
            super().__init__(f"ExpInterp({f1.name}, {f2.name}, {a})")
            self.field1 = f1
            self.field2 = f2
            self.alpha = a
            
        def evaluate(self, points):
            values1 = self.field1.evaluate(points)
            values2 = self.field2.evaluate(points)
            return values1**(1 - self.alpha) * values2**self.alpha
    
    return ExpInterpolatedField(field1, field2, alpha)
